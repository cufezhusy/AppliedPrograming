#ifndef SPARSE_VECTOR_HPP
#define SPARSE_VECTOR_HPP

#include "Vector.hpp"
#include "Matrix.hpp"
#include <set>
#include <vector>
#include <iterator>
#include <algorithm>
#include <iostream>

template<class T>
class SparseVector{
private:
	//Add your data members here!
	std::vector<unsigned int> mIndices;
	std::vector<T> mValues;
	int mDim;
public:
	//creates an empty vector of dimensionality 0.
	SparseVector ()
	{
		mDim = 0;
	}
	// Creates a vector of dimensionality dim. It starts with 0 nonzero elements
	// which need to be set using setValue
	SparseVector (unsigned int dim)
	{
		mDim = dim;
	}

	// assignment operators and copy constructor should be automatically
	// generated by the compiler when using a std::vector for internal storing.
	// However, test that assignment works!

	//sets the value v_i of the vector. if it does not exist it is added 
	void setValue(unsigned int index, T value)
	{
		if (index >= mDim)
		{
			std::cout << "Not right";
			return;
		}
		std::vector<unsigned int>::iterator pos,it;
		pos = std::lower_bound(mIndices.begin(),mIndices.end(),index);
		int k = pos - mIndices.begin();
		it = std::find(mIndices.begin(),mIndices.end(),index);
		if (it == mIndices.end())
		{
			// Not found the position, so need insert index
			mIndices.insert(pos,index);
			mValues.insert(mValues.begin() + k,value);
		}
		else
		{
			// Otherwise just override the record
			mValues[k] = value;
		}
	}

	void Print()
	{
		std::cout << "Idxs = ";
		for (std::vector<unsigned int>::const_iterator i = mIndices.begin(); i != mIndices.end(); ++i)
    		std::cout << *i << ' ';
		std::cout << "\n";

		std::cout << "Vals = ";
		for (auto  j = mValues.begin(); j != mValues.end(); ++j)
    		std::cout << *j << ' ';
		std::cout << "\n";
	}

	
	//returns the value v_i of the vector. Returns 0 if the value is not stored
	T getValue(unsigned int index)const
	{
		if (index >= mDim | index <0)
		{
			std::cout << "Not right";
			return -1;
		}

		auto it = std::find(mIndices.begin(),mIndices.end(),index);
		if (it == mIndices.end())
		{
			// Not found
			return 0;
		}
		else
		{
			int k = it - mIndices.begin();
			return mValues[k];
		}
		


	}
	
	//returns the dimensionality of the vector
	unsigned int size()const
	{
		return mDim;
	}
	
	// returns the number stored elements
	unsigned int nonZeroes()const
	{
		return mValues.size();
	}
	//returns the index of the ith stored nonzero entry (in increasing order)
	unsigned int indexNonZero(unsigned int i)const
	{
		if (i < 0 | i >= nonZeroes())
		{
			return -1;
		}
		else
		{
			return mIndices[i];
		}
		
	}
	//returns the value of the ith stored nonzero entry (in increasing order)
	T valueNonZero(unsigned int i)const
	{
		if (i < 0 | i >= nonZeroes())
		{
			return -1;
		}
		else
		{
			return mValues[i];
		}
	}
	
	//adds x too the current vector
	SparseVector<T>& operator+= (SparseVector<T> const& x)
	{
		
		for (unsigned int i=0; i < x.nonZeroes(); i++)
		{
			setValue(x.indexNonZero(i), (getValue(x.indexNonZero(i)) + x.valueNonZero(i)));
		}
		return *this;
	}


	//subtracts x from the current vector
	SparseVector<T>& operator-= (SparseVector<T> const& x)
	{
		
		for (unsigned int i=0; i < x.nonZeroes(); i++)
		{
			setValue(x.indexNonZero(i), (getValue(x.indexNonZero(i)) - x.valueNonZero(i)));
		}
		return *this;
	}
};


// computes z= x+y, equivalent to z=x, z+=y
template<class T>
SparseVector<T> operator+(SparseVector<T> const& x, SparseVector<T> const& y)
{
	SparseVector <T> z = x;
	z+=y;
	return z;
}

// computes z= x-y, equivalent to z=x, z-=y
template<class T>
SparseVector<T> operator-(SparseVector<T> const& x, SparseVector<T> const& y)
{
	SparseVector <T> z = x;
	z-=y;
	return z;
}


// computes the matrix-vector product of a dense matrix and sparse vector z=Ax.
// The result is a dense vector.
template<class T>
Vector<T> operator* (Matrix<T> const& A, SparseVector<T> const& x)
{
	unsigned int original_vector_size = x.size();
	assert(A.GetNumberOfColumns() ==(int) original_vector_size);
	int new_vector_length = A.GetNumberOfRows();
	Vector<T> new_vector(new_vector_length);

	for (int i=0; i<new_vector_length; i++)
	{
		for (int j=0; j<original_vector_size; j++)
		{
			new_vector[i] += A(i,j)*x.getValue(j);
		}
	}
	return new_vector;
}

// computes the matrix-vector product of a dense matrix and sparse vector z=x^TA.
// The result is a dense vector.
template<class T>
Vector<T> operator* (SparseVector<T> const& x, Matrix<T> const& A)
{
	unsigned int original_vector_size = x.size();
	assert(A.GetNumberOfRows() == (int) original_vector_size);
	int new_vector_length = A.GetNumberOfColumns();
	Vector<T> new_vector(new_vector_length);

	for (int i=0; i<new_vector_length; i++)
	{
		for (int j=0; j<original_vector_size; j++)
		{
			new_vector[i] += x.getValue(j)*A(j,i);
		}
	}

	return new_vector;
}


#endif